---
layout: post
title: "Construyendo un Autenticador TOTP con ESP32"
date:   2025-11-19 17:00:00 +0000
description: "C√≥mo crear tu propio autenticador de dos factores usando ESP32, compatible con Google Authenticator y otros servicios TOTP"
pubDate: 2025-11-21
tags: ["esp32", "totp", "2fa", "iot", "security", "esp-idf"]
categories: [electronica, esp32]
image:
  path: ../../assets/img/posts/prototipo/totp-esp32.png
  alt: Autenticador TOTP con ESP32
---



# Construyendo un Autenticador TOTP con ESP32

## üéØ ¬øQu√© es TOTP?

**TOTP** (Time-based One-Time Password) es un algoritmo definido en el [RFC 6238](https://tools.ietf.org/html/rfc6238) que genera c√≥digos de un solo uso basados en el tiempo actual. Es la tecnolog√≠a detr√°s de la mayor√≠a de sistemas de autenticaci√≥n de dos factores (2FA).

### ¬øC√≥mo funciona?

1. **Secret compartido**: Cuando activas 2FA en un servicio, recibes un "secret" √∫nico (generalmente en formato Base32)
2. **Timestamp**: Se usa la hora Unix actual dividida en intervalos de 30 segundos
3. **HMAC-SHA1**: Se calcula un hash usando el secret y el timestamp
4. **Truncamiento din√°mico**: Se extrae un c√≥digo de 6-8 d√≠gitos del hash

El proceso matem√°tico simplificado:

```
timestamp = unix_time / 30
hash = HMAC-SHA1(secret, timestamp)
code = hash[offset:offset+4] % 10^6
```

## üîß Hardware Utilizado

- **ESP32-WROVER-DEV** (Freenove)
- **C√°mara OV2640** (para futuras funcionalidades de escaneo QR)
- Conexi√≥n WiFi 2.4GHz

## üìê Arquitectura del Sistema

El proyecto est√° dividido en m√≥dulos bien definidos:

```
‚îú‚îÄ‚îÄ hardware/        # Gesti√≥n de WiFi, I2C, perif√©ricos
‚îú‚îÄ‚îÄ network/         # Servidor HTTP y API REST
‚îú‚îÄ‚îÄ storage/         # Persistencia en NVS Flash
‚îú‚îÄ‚îÄ totp/           # Motor TOTP, parser, almacenamiento
‚îî‚îÄ‚îÄ utils/          # Base32, NTP, helpers
```

## üöÄ Implementaci√≥n Paso a Paso

### 1. Sincronizaci√≥n de Tiempo con NTP

El componente m√°s cr√≠tico de TOTP es tener la hora exacta. Un desfase de segundos hace que los c√≥digos sean inv√°lidos.

```c
// utils/ntp.c
void ntp_sync(void) {
    ESP_LOGI(TAG, "Sincronizando con NTP");
    
    // Configurar modo de sincronizaci√≥n
    sntp_set_sync_mode(SNTP_SYNC_MODE_IMMED);
    
    // Servidor NTP
    esp_sntp_setoperatingmode(SNTP_OPMODE_POLL);
    esp_sntp_setservername(0, "pool.ntp.org");
    
    esp_sntp_init();
    
    // Esperar sincronizaci√≥n
    int retry = 0;
    while (sntp_get_sync_status() == SNTP_SYNC_STATUS_RESET && 
           retry < 20) {
        vTaskDelay(500 / portTICK_PERIOD_MS);
        retry++;
    }
    
    if (sntp_get_sync_status() == SNTP_SYNC_STATUS_COMPLETED) {
        ESP_LOGI(TAG, "Tiempo sincronizado!");
        
        // Mostrar hora actual
        time_t now;
        time(&now);
        ESP_LOGI(TAG, "Hora actual: %s", ctime(&now));
    }
}
```

**Importante**: La sincronizaci√≥n NTP debe hacerse **despu√©s** de conectar al WiFi y **antes** de generar c√≥digos TOTP.

### 2. Decodificador Base32

Los secrets TOTP vienen codificados en Base32. Necesitamos decodificarlos a bytes antes de usarlos.

```c
// utils/base32.c
int base32_decode(const char *encoded, uint8_t *decoded, size_t decoded_len) {
    size_t encoded_len = strlen(encoded);
    size_t decoded_idx = 0;
    uint32_t buffer = 0;
    int bits_in_buffer = 0;

    for (size_t i = 0; i < encoded_len; i++) {
        char c = toupper(encoded[i]);
        
        // Skip padding y espacios
        if (c == '=' || c == ' ' || c == '\n') continue;

        int value = base32_char_to_value(c);
        if (value < 0) return -1;

        buffer = (buffer << 5) | value;
        bits_in_buffer += 5;

        if (bits_in_buffer >= 8) {
            decoded[decoded_idx++] = (buffer >> (bits_in_buffer - 8)) & 0xFF;
            bits_in_buffer -= 8;
        }
    }

    return decoded_idx;
}
```

### 3. Motor TOTP - El Coraz√≥n del Sistema

La implementaci√≥n del algoritmo TOTP usando mbedtls para HMAC-SHA1:

```c
// totp/totp_engine.c
esp_err_t totp_generate_code(const char *secret_b32, 
                             uint32_t time_step, 
                             uint8_t digits, 
                             uint32_t *code) {
    // 1. Decodificar secret Base32
    uint8_t secret[128];
    int secret_len = base32_decode(secret_b32, secret, sizeof(secret));
    
    // 2. Obtener contador de tiempo
    uint64_t timestamp = get_timestamp();
    uint64_t counter = timestamp / time_step;  // Intervalos de 30s
    
    // 3. Convertir contador a bytes big-endian
    uint8_t counter_bytes[8];
    for (int i = 7; i >= 0; i--) {
        counter_bytes[i] = counter & 0xFF;
        counter >>= 8;
    }
    
    // 4. Calcular HMAC-SHA1
    uint8_t hmac[20];
    const mbedtls_md_info_t *md_info = 
        mbedtls_md_info_from_type(MBEDTLS_MD_SHA1);
    mbedtls_md_hmac(md_info, secret, secret_len, 
                    counter_bytes, 8, hmac);
    
    // 5. Truncamiento din√°mico (RFC 4226)
    int offset = hmac[19] & 0x0F;
    uint32_t binary = 
        ((hmac[offset] & 0x7F) << 24) |
        ((hmac[offset + 1] & 0xFF) << 16) |
        ((hmac[offset + 2] & 0xFF) << 8) |
        (hmac[offset + 3] & 0xFF);
    
    // 6. Generar c√≥digo de N d√≠gitos
    uint32_t modulo = 1;
    for (int i = 0; i < digits; i++) {
        modulo *= 10;
    }
    *code = binary % modulo;
    
    return ESP_OK;
}
```

### 4. Parser de URIs otpauth://

Los servicios 2FA generan URIs en formato est√°ndar:

```
otpauth://totp/GitHub:user@email.com?secret=JBSWY3DPEHPK3PXP&issuer=GitHub&digits=6&period=30
```

Nuestro parser extrae toda esta informaci√≥n:

```c
// totp/totp_parser.c
esp_err_t totp_parse_uri(const char *uri, totp_service_t *service) {
    // Validar prefijo
    if (strncmp(uri, "otpauth://totp/", 15) != 0) {
        return ESP_ERR_INVALID_ARG;
    }
    
    // Extraer label (Issuer:account)
    const char *path = uri + 15;
    const char *query = strchr(path, '?');
    
    // Parsear label decodificando URL
    char decoded_label[128];
    url_decode(decoded_label, path);
    
    // Separar issuer y account si hay ":"
    char *colon = strchr(decoded_label, ':');
    if (colon != NULL) {
        *colon = '\0';
        strncpy(service->issuer, decoded_label, MAX_ISSUER_LEN - 1);
        strncpy(service->account, colon + 1, MAX_ACCOUNT_NAME_LEN - 1);
    }
    
    // Extraer par√°metros: secret, issuer, digits, period
    get_query_param(query, "secret", service->secret, MAX_SECRET_LEN);
    get_query_param(query, "issuer", service->issuer, MAX_ISSUER_LEN);
    
    // Valores por defecto
    service->digits = 6;
    service->period = 30;
    
    return ESP_OK;
}
```

### 5. Almacenamiento Persistente en NVS

Los servicios se guardan en la partici√≥n NVS Flash del ESP32:

```c
// totp/totp_storage.c
esp_err_t totp_storage_add(const totp_service_t *service) {
    // Agregar al cache en memoria
    memcpy(&services[service_count], service, sizeof(totp_service_t));
    service_count++;
    
    // Guardar en NVS
    nvs_handle_t handle;
    nvs_open("totp_storage", NVS_READWRITE, &handle);
    
    // Guardar contador
    nvs_set_u8(handle, "svc_count", service_count);
    
    // Guardar cada servicio
    char key[16];
    for (int i = 0; i < service_count; i++) {
        snprintf(key, sizeof(key), "svc_%d", i);
        nvs_set_blob(handle, key, &services[i], sizeof(totp_service_t));
    }
    
    nvs_commit(handle);
    nvs_close(handle);
    
    return ESP_OK;
}
```

### 6. Interfaz Web Moderna

La interfaz est√° construida como una SPA (Single Page Application) embebida en el ESP32:

```html
<!-- network/www/index.html -->
<div class="container">
    <h1>üîê ESP32 TOTP</h1>
    
    <!-- Formulario para agregar servicios -->
    <div class="card">
        <input id="uri-input" 
               placeholder="otpauth://totp/Service:user@email.com?secret=...">
        <button onclick="addService()">Agregar</button>
    </div>
    
    <!-- Lista de servicios -->
    <div id="services-list"></div>
    
    <!-- Vista de c√≥digo -->
    <div class="code-display" id="code-value">------</div>
    <div class="progress-bar">
        <div class="progress-fill" id="progress"></div>
    </div>
</div>

<script>
async function addService() {
    const uri = document.getElementById('uri-input').value;
    
    const response = await fetch('/api/services', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ uri: uri })
    });
    
    if (response.ok) {
        loadServices();
    }
}

async function updateCode() {
    const response = await fetch(`/api/code/${currentIndex}`);
    const data = await response.json();
    
    document.getElementById('code-value').textContent = 
        data.code.toString().padStart(6, '0');
    
    const progress = (data.remaining / 30) * 100;
    document.getElementById('progress').style.width = progress + '%';
}

setInterval(updateCode, 1000);
</script>
```

### 7. API REST

El servidor HTTP expone endpoints RESTful:

```c
// network/server.c

// GET /api/services - Listar servicios
static esp_err_t api_services_get_handler(httpd_req_t *req) {
    char *json = totp_storage_list_json();
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json, HTTPD_RESP_USE_STRLEN);
    free(json);
    return ESP_OK;
}

// POST /api/services - Agregar servicio
static esp_err_t api_services_post_handler(httpd_req_t *req) {
    char *buf = malloc(512);
    httpd_req_recv(req, buf, 512);
    
    cJSON *root = cJSON_Parse(buf);
    const char *uri = cJSON_GetObjectItem(root, "uri")->valuestring;
    
    totp_service_t service;
    totp_parse_uri(uri, &service);
    totp_storage_add(&service);
    
    cJSON_Delete(root);
    free(buf);
    
    httpd_resp_send(req, "{\"success\":true}", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

// GET /api/code/{index} - Obtener c√≥digo TOTP
static esp_err_t api_code_get_handler(httpd_req_t *req) {
    int index = atoi(strrchr(req->uri, '/') + 1);
    
    totp_service_t service;
    totp_storage_get(index, &service);
    
    uint32_t code;
    totp_get_code(service.secret, service.digits, &code);
    uint32_t remaining = totp_get_remaining_seconds(service.period);
    
    char response[256];
    snprintf(response, sizeof(response),
        "{\"code\":%lu,\"remaining\":%lu,\"service\":\"%s\"}", 
        code, remaining, service.issuer);
    
    httpd_resp_send(req, response, HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}
```

## üîí Seguridad y Consideraciones

### Ventajas
- ‚úÖ Genera c√≥digos **id√©nticos** a Google Authenticator
- ‚úÖ **Persistencia** - los servicios sobreviven a reinicios
- ‚úÖ **C√≥digo abierto** - puedes auditar toda la seguridad

### Limitaciones
- ‚ö†Ô∏è Secrets guardados en NVS **sin cifrado adicional**
- ‚ö†Ô∏è Red WiFi debe ser **segura**
- ‚ö†Ô∏è No tiene **autenticaci√≥n** en la interfaz web
- ‚ö†Ô∏è Reloj depende de **sincronizaci√≥n NTP**

### Mejoras Futuras
- üîÑ Cifrado de secrets usando secure boot
- üîÑ Autenticaci√≥n web con login/password
- üîÑ Backup/restore de servicios
- üîÑ Escaneo de c√≥digos QR con c√°mara
- üîÑ Display f√≠sico para uso sin WiFi

## üìä Rendimiento

- **Generaci√≥n de c√≥digo**: ~5ms
- **Uso de RAM**: ~40KB
- **Flash ocupado**: ~830KB
- **Capacidad**: hasta 20 servicios

## üß™ Prob√°ndolo

Para probar con un servicio real:

1. Ve a GitHub ‚Üí Settings ‚Üí Security ‚Üí 2FA
2. Selecciona "Configurar manualmente"
3. Copia la URI completa: `otpauth://totp/GitHub:user@...`
4. P√©gala en la interfaz del ESP32
5. Compara el c√≥digo generado con Google Authenticator

¬°Deber√≠an ser **id√©nticos**!

## üíª C√≥digo Fuente

El proyecto completo est√° disponible en GitHub:

üëâ [https://github.com/ggenzone/maker/esp32/05-TOTP](https://github.com/ggenzone/maker/tree/main/code/esp32/05-TOTP)

## üéì Lo Aprendido

Este proyecto me ense√±√≥ sobre:

- **Criptograf√≠a pr√°ctica**: HMAC, hashing, c√≥digos de un solo uso
- **Protocolos est√°ndar**: RFC 6238, RFC 4226
- **Tiempo real en embedded**: Sincronizaci√≥n NTP, timestamps
- **Persistencia en flash**: Uso de NVS en ESP32
- **Desarrollo web embebido**: Server HTTP, APIs REST, SPAs
- **Debugging complejo**: C√≥digos incorrectos por timezone o desfase de reloj

## Referencias

- [RFC 6238 - TOTP](https://tools.ietf.org/html/rfc6238)
- [RFC 4226 - HOTP](https://tools.ietf.org/html/rfc4226)
- [ESP-IDF Programming Guide](https://docs.espressif.com/projects/esp-idf/)
- [Google Authenticator Key URI Format](https://github.com/google/google-authenticator/wiki/Key-Uri-Format)
